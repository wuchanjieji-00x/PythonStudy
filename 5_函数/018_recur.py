# !/usr/bin/env python3
# -*- coding: utf-8 -*-

# 递归函数
# 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数

def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)
print (fact(1))
print (fact(5))
print (fact(10))
        
# 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
# 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
# 每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：
# print (fact(1000))

# 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。


# 利用递归函数计算阶乘
# N! = 1 * 2 * 3 * ... * N
def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)

print('fact(1) =', fact(1))
print('fact(5) =', fact(5))
print('fact(10) =', fact(10))

# 利用递归函数移动汉诺塔:
def move(n, a, b, c):  # a是起始，b是辅助，c是目标
    if n == 1:
        print('move', a, '-->', c) # 只有一个盘子，从起始移动到目标
    else:
        move(n-1, a, c, b) # a是起始，b是辅助，将n-1个盘子从起始移动到辅助。
        # 此时，成为一个新的问题，a是起始，b是目标，c是辅助
        move(1, a, b, c)   # a是起始，c是目标，将剩余1个盘子从起始移动到目标
        move(n-1, b, a, c) # b是辅助，c是目标，将辅助上的盘子移动到目标
        # 此时，成为一个新的问题，b是起始，a是辅助，c是目标

move(4, 'A', 'B', 'C')  # 见所属文件夹里的图片